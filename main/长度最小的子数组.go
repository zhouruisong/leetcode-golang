package main

import (
	"fmt"
	"math"
)

/* 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s
* 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。
*
* 示例:
*
* 输入: s = 7, nums = [2,3,1,2,4,3]
* 输出: 2
* 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
*
*
* 进阶:
*
* 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。
*
 */

/*用双指针 left 和 right 表示一个窗口。
right 向右移增大窗口，直到窗口内的数字和大于等于了 s。进行第 2 步。
记录此时的长度，left 向右移动，开始减少长度，每减少一次，就更新最小长度。直到当前窗口内的数字和小于了 s，回到第 1 步。
举个例子，模拟下滑动窗口的过程吧。

s = 7, nums = [2,3,1,2,4,3]

2 3 1 2 4 3
^
l
r
上边的窗口内所有数字的和 2 小于 7, r 右移

2 3 1 2 4 3
^ ^
l r
上边的窗口内所有数字的和 2 + 3 小于 7, r 右移

2 3 1 2 4 3
^   ^
l   r
上边的窗口内所有数字的和 2 + 3 + 1 小于 7, r 右移

2 3 1 2 4 3
^     ^
l     r
上边的窗口内所有数字的和 2 + 3 + 1 + 2 大于等于了 7, 记录此时的长度 min = 4, l 右移

2 3 1 2 4 3
  ^   ^
  l   r
上边的窗口内所有数字的和 3 + 1 + 2  小于 7, r 右移

2 3 1 2 4 3
  ^     ^
  l     r
上边的窗口内所有数字的和 3 + 1 + 2 + 4 大于等于了 7, 更新此时的长度 min = 4, l 右移

2 3 1 2 4 3
    ^   ^
    l   r
上边的窗口内所有数字的和 1 + 2 + 4 大于等于了 7, 更新此时的长度 min = 3, l 右移

2 3 1 2 4 3
      ^ ^
      l r
上边的窗口内所有数字的和 2 + 4 小于 7, r 右移

2 3 1 2 4 3
      ^   ^
      l   r
上边的窗口内所有数字的和 2 + 4 + 3 大于等于了 7, 更新此时的长度 min = 3, l 右移

2 3 1 2 4 3
        ^ ^
        l r
上边的窗口内所有数字的和 4 + 3 大于等于了 7, 更新此时的长度 min = 2, l 右移

2 3 1 2 4 3
          ^
          r
          l
上边的窗口内所有数字的和 3 小于 7, r 右移，结束
*/

//双指针
func minSubArrayLen(s int, nums []int) int {
	//滑窗法
	n := len(nums)
	if n == 0 {
		return 0
	}

	left, right, sum := 0, 0, 0
	ans := math.MaxInt32

	for right < n {
		sum += nums[right]
		right++

		for sum >= s {
			if right-left < ans {
				ans = right - left
			}
			sum -= nums[left]
			left++
		}
	}

	if ans == math.MaxInt32 {
		return 0
	}

	return ans
}

func main() {
	//arr := []int{2, 3, 1, 2, 4, 3}
	arr := []int{1, 2, 3, 4, 5}
	s := 11
	fmt.Println(minSubArrayLen(s, arr))
}
